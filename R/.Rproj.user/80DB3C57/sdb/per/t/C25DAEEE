{
    "contents" : "# Script holding handy functions\n\n# Correlate two raster stacks\nstackcor <- function(s1, s2, method='spearman') {\n  mycor <- function(v) {\n    x <- v[1:split]\n    y <- v[(split+1):(2*split)]\n    cor(x, y, method=method)\n  }\n  s <- stack(s1, s2)\n  split <- nlayers(s)/2\n  calc(s, fun=mycor )\n}\n\n# Create matrix plot of correlation matrix\n# Circle size represents strength of correlation\n# Circle color represents direction of correlation\n# From http://gallery.r-enthusiasts.com/graph/Correlation_matrix_circles_152\ncircle.corr <- function(corr, col=c(\"black\",\"white\"), bg = \"white\",\n                        cex = 1, order = FALSE, title = \"\", ...){\n  \n  if (is.null(corr))\n    return(invisible())\n  if ((!is.matrix(corr)) || (round(min(corr, na.rm = TRUE),\n                                   6) < -1) || (round(max(corr, na.rm = TRUE), 6) > 1))\n    stop(\"Need a correlation matrix!\")\n  n <- nrow(corr)\n  m <- ncol(corr)\n  \n  ## reorder the variables using principal component analysis\n  if (order) {\n    if(!n==m){\n      stop(\"The matrix must be squre if order is TRUE!\")\n    }\n    x.eigen <- eigen(corr)$vectors[, 1:2]\n    e1 <- x.eigen[, 1]\n    e2 <- x.eigen[, 2]\n    alpha <- ifelse(e1 > 0, atan(e2/e1), atan(e2/e1) + pi)\n    corr <- corr[order(alpha), order(alpha)]\n  }\n  \n  ## set up variable names\n  rname <- rownames(corr)\n  cname <- colnames(corr)\n  if (is.null(rname))\n    rname <- 1:n\n  if (is.null(cname))\n    cname <- 1:m\n  rname <- as.character(rname)\n  cname <- as.character(cname)\n  \n  ## calculate label-text width approximately\n  par(mar = c(0, 0, 2, 0), bg = \"white\")\n  plot.new()\n  plot.window(c(0, m), c(0, n), asp = 1)\n  xlabwidth <- max(strwidth(rname, cex = cex))\n  ylabwidth <- max(strwidth(cname, cex = cex))\n  \n  ## set up an empty plot with the appropriate dimensions\n  plot.window(c(-xlabwidth + 0.5, m + 0.5), c(0, n + 1 + ylabwidth),\n              asp = 1, xlab=\"\", ylab=\"\")\n  rect(0.5, 0.5, m + 0.5, n + 0.5, col = bg)  ##background color\n  \n  ## add variable names and title\n  text(rep(-xlabwidth/2, n), n:1, rname, col = \"red\", cex = cex)\n  text(1:m, rep(n + 1 + ylabwidth/2, m), cname, srt = 90, col = \"red\",\n       cex = cex)\n  title(title)\n  \n  ## add grid\n  segments(rep(0.5, n + 1), 0.5 + 0:n, rep(m + 0.5, n + 1),\n           0.5 + 0:n, col = \"gray\")\n  segments(0.5 + 0:m, rep(0.5, m + 1), 0.5 + 0:m, rep(n + 0.5,\n                                                      m), col = \"gray\")\n  \n  ## assign circles' fill color\n  nc <- length(col)\n  if(nc==1)\n    bg <- rep(col, n*m)\n  else{\n    ff <- seq(-1,1, length=nc+1)\n    bg2 = rep(0, n * m)\n    for (i in 1:(n * m)){\n      bg2[i] <- rank(c(ff[2:nc], as.vector(corr)[i]),\n                     ties.method = \"random\")[nc]\n    }\n    bg <- (col[nc:1])[bg2]\n  }\n  \n  ## plot n*m circles using vector language, suggested by Yihui Xie\n  ## the area of circles denotes the absolute value of coefficient\n  symbols(rep(1:m, each = n), rep(n:1, m), add = TRUE, inches = F,\n          circles = as.vector(sqrt(abs(corr))/2), bg = as.vector(bg))\n  \n  # Create binary vector. 1 where corr stat is greater than threshold, 0 where not\n  zz <- as.vector(ifelse(corr >= 0.75 | corr <= -0.6, 1, 0))\n  \n  points(rep(1:m, each = n)[zz==1], rep(n:1, m)[zz==1], pch=16, col=\"yellow\")\n}\n\n",
    "created" : 1367338438215.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "489158989",
    "id" : "C25DAEEE",
    "lastKnownWriteTime" : 1367347335,
    "path" : "C:/Share/pjantz/Scripts/LCCVP/handy_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}